#pragma once

#include "error.h"
#include "utils.h"
#include <stdbool.h>
#include <stddef.h>

#define NB_BRAM_INTERFACE 5

/**
 * Contains the relevant infomations for an non-array argument of the
 *accelerated function
 **/
typedef struct _hdl_in_param {
    char name[MAX_NAME_LENGTH];
    uint16_t width;
} hdl_in_param_t;

/**
 * List of ports from the accelerator that will directly interface with the
 *BRAMs
 **/
typedef struct _bram_interface {
    char address[MAX_NAME_LENGTH];
    char ce[MAX_NAME_LENGTH];
    char we[MAX_NAME_LENGTH];
    char dout[MAX_NAME_LENGTH];
    char din[MAX_NAME_LENGTH];
} bram_interface_t;

/**
 * Contains every infomation for arrays
 * One of the BRAM interface might no be used
 **/
typedef struct _hdl_array {
    char name[MAX_NAME_LENGTH];
    bram_interface_t read_ports;
    bram_interface_t write_ports;
    bool read;
    bool write;
    uint16_t width;
} hdl_array_t;

/**
 * Contains all information we can get form the top HDL file generated by
 * Dynamatic
 **/
typedef struct _hdl_info {
    char top_file_path[MAX_PATH_LENGTH];
    char dir[MAX_PATH_LENGTH];
    char name[MAX_NAME_LENGTH];
    char top_file_name[MAX_NAME_LENGTH];
    hdl_array_t *arrays;
    hdl_in_param_t *params;
    size_t nb_arrays;
    size_t nb_params;
    char *source;
    size_t end_of_ports_decl;
    size_t end_arrays;
    uint16_t end_out_width;
    uint16_t max_param_width;
} hdl_info_t;

/**
 * Creates an hdl_info_t struct. Initialize it and asks for the Dynamatic
 *output path.
 *
 * @param hdl_info the struct that will be initialized
 *
 *@return an error code
 **/
auto_error_t hdl_create(hdl_info_t *hdl_info);

/**
 * Parse the top HDL file generated by Dynamatic
 *
 * @param hdl_info will be filled with the relevant information
 *
 * @return an error code
 **/
auto_error_t parse_hdl(hdl_info_t *hdl_info);

/**
 * Free an hdl_info struct
 *
 * @param hdl_info the struct that needs to be freed
 *
 * @return an error code
 *
 **/
auto_error_t hdl_free(hdl_info_t *hdl_info);